<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Top View - Pista 3D</title>
<style>
 body { margin:0; overflow:hidden; background:#000; }
 canvas { display:block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
// =========================
// CONFIG BASICA
// =========================
const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");
if(!gl) alert("WebGL não suportado");

// =========================
// SHADERS
// =========================
const vs = `
attribute vec3 aPos;
uniform mat4 uProj, uView, uModel;
void main(){ gl_Position = uProj * uView * uModel * vec4(aPos,1.0); }
`;

const fs = `
precision mediump float;
uniform vec3 uColor;
void main(){ gl_FragColor = vec4(uColor,1.0); }
`;

function compile(type, src){ let s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); return s; }
let prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog,"aPos");
const uProj = gl.getUniformLocation(prog,"uProj");
const uView = gl.getUniformLocation(prog,"uView");
const uModel = gl.getUniformLocation(prog,"uModel");
const uColor = gl.getUniformLocation(prog,"uColor");

// =========================
// GEOMETRIA
// =========================
const trackVerts = new Float32Array([
   -3,0,0,   3,0,0,   3,0,-2000,
   -3,0,0,   3,0,-2000,   -3,0,-2000
]);

const lines = [];
for(let i=0;i<2000;i+=10){
   lines.push(-0.05,0.01,-i, 0.05,0.01,-i, 0.05,0.01,-i-2);
   lines.push(-0.05,0.01,-i, 0.05,0.01,-i-2, -0.05,0.01,-i-2);
}
const lineVerts = new Float32Array(lines);

const walls = [];
for(let z=0; z>-2000; z-=4){
    walls.push(-3,0,z, -3,1,z, -3,1,z-4);
    walls.push(-3,0,z, -3,1,z-4, -3,0,z-4);
    walls.push(3,0,z, 3,1,z, 3,1,z-4);
    walls.push(3,0,z, 3,1,z-4, 3,0,z-4);
}
const wallVerts = new Float32Array(walls);

function makeBuffer(data){ let b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW); return {buffer:b, count:data.length/3}; }
const bufTrack = makeBuffer(trackVerts);
const bufLines = makeBuffer(lineVerts);
const bufWalls = makeBuffer(wallVerts);

// =========================
// CAMERA FIXA ACIMA + ZOOM NO MOUSE
// =========================
let camHeight = 150;
let camZoom = 150;

window.addEventListener("wheel", e=>{
    camZoom += e.deltaY * 0.2;
    camZoom = Math.max(50, Math.min(400, camZoom));
});

function lookAt(px,py,pz, tx,ty,tz){
 let zx = px-tx, zy = py-ty, zz = pz-tz;
 let rl = 1/Math.hypot(zx,zy,zz);
 zx*=rl; zy*=rl; zz*=rl;
 let xx = 0*zz - 1*zy;
 let xy = 1*zx - 0*zz;
 let xz = 0*zy - 0*zx;
 let xl = 1/Math.hypot(xx,xy,xz);
 xx*=xl; xy*=xl; xz*=xl;
 let yx = zy*xz - zz*xy;
 let yy = zz*xx - zx*xz;
 let yz = zx*xy - zy*xx;
 return new Float32Array([
   xx, yx, zx, 0,
   xy, yy, zy, 0,
   xz, yz, zz, 0,
   -(xx*px+xy*py+xz*pz),
   -(yx*px+yy*py+yz*pz),
   -(zx*px+zy*py+zz*pz), 1
 ]);
}

function perspective(fov,aspect,near,far){
 let f = 1/Math.tan(fov/2), nf=1/(near-far);
 return new Float32Array([
  f/aspect,0,0,0,
  0,f,0,0,
  0,0,(far+near)*nf,-1,
  0,0,(2*far*near)*nf,0
 ]);
}

const proj = perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 5000);

function identity(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }

function drawBuffer(buf,color,model){
 gl.uniform3fv(uColor,color);
 gl.uniformMatrix4fv(uModel,false,model);
 gl.bindBuffer(gl.ARRAY_BUFFER, buf.buffer);
 gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
 gl.enableVertexAttribArray(aPos);
 gl.drawArrays(gl.TRIANGLES,0,buf.count);
}

// =========================
// LOOP
// =========================
function loop(){
 requestAnimationFrame(loop);

 const view = lookAt(0,camZoom, -1000,  0,0,-1000);
 gl.uniformMatrix4fv(uProj,false,proj);
 gl.uniformMatrix4fv(uView,false,view);

 gl.clearColor(0.2,0.2,0.25,1);
 gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
 gl.enable(gl.DEPTH_TEST);

 drawBuffer(bufTrack,[0.2,0.2,0.2],identity());
 drawBuffer(bufLines,[1,1,1],identity());
 drawBuffer(bufWalls,[0.8,0.1,0.1],identity());
}
loop();
</script>
</body>
</html>

/* BACKGROUND MAR SECTION */
// Fundo azul "mar" ocupando metade da tela e descendo conforme a pista acaba
const fundoMar = document.createElement('div');
fundoMar.id = 'fundoMar';
fundoMar.style.position = 'absolute';
fundoMar.style.left = '0';
fundoMar.style.top = '0';
fundoMar.style.width = '100%';
fundoMar.style.height = '50%';
fundoMar.style.background = 'linear-gradient(#3aa0ff, #004d80)';
fundoMar.style.zIndex = '0';
document.body.appendChild(fundoMar);

function atualizarFundoMar(fimPistaY, posicaoCarroY) {
    const proporcao = Math.min(1, posicaoCarroY / fimPistaY);
    fundoMar.style.height = `${50 + proporcao * 50}%`;
}

/* LEFT WALL */
const muretaEsquerda = document.createElement('div');
muretaEsquerda.id = 'muretaEsquerda';
muretaEsquerda.style.position = 'absolute';
muretaEsquerda.style.left = '0';
muretaEsquerda.style.top = '0';
muretaEsquerda.style.width = '40px';
muretaEsquerda.style.height = '100%';
muretaEsquerda.style.background = '#666';
muretaEsquerda.style.borderRight = '4px solid #333';
muretaEsquerda.style.zIndex = '5';
document.body.appendChild(muretaEsquerda);

/* BALL JS FILE SEPARATED */
// Código isolado para ser movido a outro arquivo depois
export function iniciarBolinha(canvas, pista) {
    const bola = {
        x: canvas.width / 2,
        y: 50,
        r: 8,
        vel: 2
    };

    function desenhar(ctx) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(bola.x, bola.y, bola.r, 0, Math.PI * 2);
        ctx.fill();
    }

    function atualizar() {
        bola.y += bola.vel;
    }

    return { bola, desenhar, atualizar };
}

